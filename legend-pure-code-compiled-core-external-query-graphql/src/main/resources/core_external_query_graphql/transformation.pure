// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


###Pure
import meta::external::query::graphQL::metamodel::*;
import meta::external::query::graphQL::metamodel::typeSystem::*;
import meta::external::query::graphQL::binding::toPure::*;

function meta::external::query::graphQL::binding::toPure::primitiveTypeMapping() : Pair<String, meta::pure::metamodel::type::Type>[*]
{
    [
      pair('String', String),
      pair('Boolean', Boolean),
      pair('Object', Any),
      pair('Int', Integer),
      pair('Float', Float),
      pair('ID', String)
    ]
}

function meta::external::query::graphQL::binding::toPure::typeSystem::graphQLTypeSystemtoPure(doc:Document[1], package:String[1]) : meta::pure::metamodel::type::Type[*]
{
  let pack = buildTransientPackageFromString($package);

  // Pass 1
  let typesByName = $doc.definitions->map(def|
    $def->match(
      [
        o : ObjectTypeDefinition[1] | let no = newClass($o.name);
                                      let cp = ^$no(package = $pack);
                                      pair($o.name, $cp);,
        e : EnumTypeDefinition[1] | let ne = newEnumeration($e.name, $e.values.value);
                                    let ep = ^$ne(package = $pack);
                                    pair($e.name, $ep);
      ]
    )
  )->concatenate(meta::external::query::graphQL::binding::toPure::primitiveTypeMapping())->newMap();

  // Pass 2
  $doc.definitions->map(def|
    $def->match(
      [
        o : ObjectTypeDefinition[1] | let ownerType = $typesByName->get($o.name)->toOne();
                                      let ownerGType = ^GenericType(rawType=$ownerType);
                                      let properties = $o.fields->map(f |
                                          let targetName = $f.type->match([
                                            o:NamedTypeReference[1] | pair(if($o.nullable,|ZeroOne,|PureOne), $o.name),
                                            l:ListTypeReference[1] | pair(ZeroMany, $l.itemType->cast(@NamedTypeReference).name)
                                          ]);
                                          let targeType = $typesByName->get($targetName.second)->toOne();
                                          meta::pure::functions::meta::newProperty($f.name, $ownerGType, ^GenericType(rawType=$targeType), $targetName.first);
                                      );
                                      $ownerType->mutateAdd('properties', $properties);,
        e : EnumTypeDefinition[1] | $typesByName->get($e.name)->toOne();
      ]
    )
  );
}

function meta::external::query::graphQL::binding::toPure::buildTransientPackageFromString(package:String[1]) : Package[1]
{
  $package->split('::')->fold({a,b|^Package(name = $a, package=$b)}, ^Package());
}



###Pure
import meta::external::query::graphQL::metamodel::*;
import meta::external::query::graphQL::metamodel::value::*;
import meta::external::query::graphQL::metamodel::executable::*;
import meta::external::query::graphQL::transformation::queryToPure::*;
import meta::pure::graphFetch::*;

function meta::external::query::graphQL::transformation::queryToPure::graphQLExecutableToPure(query:Document[1], root: Class<Any>[1]) : RootGraphFetchTree<Any>[1]
{
  let types = $root->meta::external::query::graphQL::binding::fromPure::introspection::scanTypes([]);
  let fragments = $query.definitions->map(d|
    $d->match([
      
      f : FragmentDefinition[1]| pair($f.name, list($f.selectionSet->transformSelectionToPure($types->filter(c|$c.name == $f.typeCondition)->toOne()->cast(@Class<Any>))));,
      o : OperationDefinition[1]| pair('__Query', list($o.selectionSet->transformSelectionToPure($root)));
    ])    
  )->newMap();
//  println('$fragments->get(__Query)->toOne().values');
  // println($fragments->get('__Query')->toOne().values);
//  println($query->meta::external::query::graphQL::serialization::graphQLtoString());
  ^RootGraphFetchTree<Any>
  (
    class = $root,
    subTrees = $fragments->get('__Query')->toOne().values->buildGraphFetchFromIntermediateNodes($fragments)
  );
}



Class <<access.private>> meta::external::query::graphQL::transformation::queryToPure::IntermediateNode
{
}

Class <<access.private>> meta::external::query::graphQL::transformation::queryToPure::IntermediatePropertyNode extends IntermediateNode
{
  children :  meta::external::query::graphQL::transformation::queryToPure::IntermediateNode[*];
  propertyFetch : PropertyGraphFetchTree[1];
}

Class <<access.private>> meta::external::query::graphQL::transformation::queryToPure::IntermediateFragmentNode extends IntermediateNode
{
  name : String[1];
}

function <<access.private>> meta::external::query::graphQL::transformation::queryToPure::transformSelectionToPure(selection:Selection[*], root:Class<Any>[1]) : meta::external::query::graphQL::transformation::queryToPure::IntermediateNode[*]
{
  $selection->map(s|$s->match(
    [
      field : Field[1] |let property = $root->meta::pure::functions::meta::hierarchicalProperties()->concatenate($root->meta::pure::functions::meta::hierarchicalQualifiedProperties())->filter(p|$p.name == $field.name);
                        assert(!$property->isEmpty(), |'Property "'+$field.name+'" can\'t be found in the type '+$root->elementToPath());
                        ^meta::external::query::graphQL::transformation::queryToPure::IntermediatePropertyNode
                        (
                          propertyFetch = ^PropertyGraphFetchTree
                                          (
                                            property = $property->toOne(),
                                            parameters = $field.arguments->map(a|$a.value->match(
                                                                                            [
                                                                                              s:StringValue[1]| ^InstanceValue(multiplicity=PureOne, genericType=^GenericType(rawType=String), values=$s.value),
                                                                                              b:BooleanValue[1]| ^InstanceValue(multiplicity=PureOne, genericType=^GenericType(rawType=Boolean), values=$b.value),
                                                                                              o:ObjectValue[1]| ^InstanceValue(multiplicity=PureOne, genericType=^GenericType(rawType=Any), values=$o.value)
                                                                                            ]
                                                                                          )
                                                                           )
                                          ),
                          children = if ($field.selectionSet->isEmpty(),|[],|$field.selectionSet->transformSelectionToPure($property->toOne()->functionReturnType().rawType->cast(@Class<Any>)->toOne()))
                        );,
      fragmentId : FragmentSpread[1] | ^meta::external::query::graphQL::transformation::queryToPure::IntermediateFragmentNode(name = $fragmentId.name);
    ]
  ));
}

function <<access.private>> meta::external::query::graphQL::transformation::queryToPure::buildGraphFetchFromIntermediateNodes(nodes : meta::external::query::graphQL::transformation::queryToPure::IntermediateNode[*], fragments : Map<String, List<meta::external::query::graphQL::transformation::queryToPure::IntermediateNode>>[1]) : PropertyGraphFetchTree[*]
{
  $nodes->map(n | $n->match(
      [
        p : meta::external::query::graphQL::transformation::queryToPure::IntermediatePropertyNode[1] | let val = $p.propertyFetch;
                                                                                           ^$val
                                                                                           (
                                                                                             subTrees = $p.children->buildGraphFetchFromIntermediateNodes($fragments)
                                                                                           );,
        f : meta::external::query::graphQL::transformation::queryToPure::IntermediateFragmentNode[1] | $fragments->get($f.name).values->buildGraphFetchFromIntermediateNodes($fragments)
      ]
    )
  )
}


###Pure
import meta::external::query::graphQL::transformation::queryToPure::*;
import meta::external::query::graphQL::metamodel::*; 
import meta::external::query::graphQL::metamodel::value::*; 
import meta::external::query::graphQL::metamodel::executable::*; 
import meta::json::*;
import meta::pure::graphFetch::executionPlan::*;
import meta::pure::executionPlan::*;

function meta::legend::crud::hugo::tests::persist2<T>(input: T[1]): T[1]
{
  $input;
}



function meta::external::query::graphQL::transformation::queryToPure::persistFromJSONObjectString<T>(class: Class<T>[1], inputJsonObjStr: String[1]): T[1]
{
   let inputJsonObj = meta::json::parseJSON($inputJsonObjStr)->cast(@meta::json::JSONObject);
   meta::external::query::graphQL::transformation::queryToPure::persistFromJSONObject($class, $inputJsonObj);  
}

function meta::external::query::graphQL::transformation::queryToPure::persistFromJSONObject<T>(class: Class<T>[1], inputJsonObj: JSONObject[1]): T[1]
{
  // println('t0');
 // HG: do we need to omit in case we get JSON with ID or any other non-expect key? or just throw?
  let inputJsonObjPersisted = ^meta::json::JSONObject(keyValuePairs=[concatenate($inputJsonObj.keyValuePairs->filter
    (kv | !$kv.key.value->equal('id')),meta::json::newJSONKeyValue('id', ^meta::json::JSONNumber(value=123))) ]);
    let inputStr = toJSON($inputJsonObjPersisted);
    // println('$inputStr');
    // println($inputStr);
    let result = meta::json::fromJSON($inputJsonObjPersisted, $class)->cast(@T)->toOne();
  //       println('re3');
  //       println($re3);
  //  let res2 = meta::json::fromJSON($inputJsonObjPersisted, $class->cast(@Class<T>))->genericType()->genericTypeClass()->cast(@Class<T>);
  //    println('t1');
    // println($result->meta::json::toJSON());
   $result;
}


// Given a root query with a named qualifiedProperty ie. 
// Class RootQuery {
// persistFirm(input: meta::legend::crud::hugo::tests::domain::Firm[1]) { $input->meta::legend::crud::hugo::tests::persist()}: meta::legend::crud::hugo::tests::domain::Firm[1];  
// }

function meta::external::query::graphQL::transformation::queryToPure::extractPersistFuncFromRootQueryClass(rootQuery: Class<Any>[1], mutationName: String[1]): Function<Any>[1] {
  let input = ^meta::external::query::graphQL::serialization::tests::Firm(name='my firm', address='street 123', id=1);
let extractedQP = $rootQuery->meta::pure::functions::meta::classQualifiedPropertyByName($mutationName);
// println( $extractedQP->toOne().expressionSequence->cast(@SimpleFunctionExpression)->evaluateAndDeactivate()->toOne().func->evaluate(^List<Any>(values=$input)));

// println( $extractedQP->toOne().expressionSequence->cast(@SimpleFunctionExpression)->evaluateAndDeactivate()->toOne().func);


//   //  $extractedQP->toOne().expressionSequence.func->cast(Function)->meta::pure::functions::lang::evaluate(^List<Any>(values=$input));
// // native function meta::pure::functions::lang::evaluate(func:Function<Any>[1], params:List<Any>[*]):Any[*];
// let persistInputClass =  $extractedQP->toOne()->functionType().parameters->evaluateAndDeactivate()->tail()->at(0).genericType.rawType->toOne()->cast(@Class<Any>);

// println('extractPersistFuncFromRootQueryClass:\n');
// // println($persistInputClass);
// $persistInputClass;
$extractedQP->toOne().expressionSequence->cast(@SimpleFunctionExpression)->evaluateAndDeactivate()->toOne().func;
}
// native function meta::pure::functions::lang::evaluate(func:Function<Any>[1], params:List<Any>[*]):Any[*];
// native function meta::pure::functions::meta::deactivate(var:Any[*]):ValueSpecification[1];
// native function meta::pure::functions::meta::reactivate(vs:ValueSpecification[1], vars:Map<String, List<Any>>[1]):Any[*];
// extract the inut class type ( so we can use it for persist function) ie. return Class meta::legend::crud::hugo::tests::domain::Firm
function meta::external::query::graphQL::transformation::queryToPure::extractInputClassFromRootQueryClass(rootQuery: Class<Any>[1], mutationName: String[1]):Class<Any>[1] {

let extractedQP = $rootQuery->meta::pure::functions::meta::classQualifiedPropertyByName($mutationName);
let persistInputClass =  $extractedQP->toOne()->functionType().parameters->evaluateAndDeactivate()->tail()->at(0).genericType.rawType->toOne()->cast(@Class<Any>);

// println('extractInputClassFromRootQueryClass:\n');
// println($persistInputClass);
$persistInputClass;
}


function meta::external::query::graphQL::transformation::queryToPure::extractMutationNameAndInputFromGQLQuery(queryGQL:meta::external::query::graphQL::metamodel::Document[1]): Pair<String, meta::json::JSONObject>[1] {


 // mutation with input variables payload 
  //  let gqlDocument = ^Document(
  //   definitions = 
  //     [
  //       ^OperationDefinition(
  //         type = OperationType.mutation,
  //         name = 'persistFirm',
  //         variables = [],
  //         directives = [],
  //         selectionSet = ^Field(
  //           name = 'persistFirm',
  //           arguments = [
  //              ^Argument(name='input', value=^ObjectValue(value=$inputJsonObjPersisted))
  //           ],
  //           directives = [],
  //           selectionSet = [
  //             ^Field(
  //              name = 'id',
  //             arguments = [],
  //             directives = []
  //           ),
  //             ^Field(
  //              name = 'name',
  //             arguments = [],
  //             directives = []
  //           )
  //           ]
  //         )
  //       )
  //     ]
  // );

  let mutationName = $queryGQL.definitions->first()->cast(@OperationDefinition).selectionSet->cast(@Field).name->toOne(); 
 let mutationInputJsonObj =  $queryGQL.definitions->first()->cast(@OperationDefinition).selectionSet->cast(@Field).arguments->first().value->cast(@ObjectValue).value->cast(@JSONObject)->toOne();
// println($queryGQL.definitions->first()->cast(@OperationDefinition).selectionSet->cast(@Field).arguments->first().value->cast(@ObjectValue).value->cast(@JSONObject));
^Pair<String, meta::json::JSONObject>(first=$mutationName, second=$mutationInputJsonObj);
}

function meta::external::query::graphQL::transformation::queryToPure::getMutationPlansFromGraphQL(
                                                                          cl:Class<Any>[1],
                                                                          mapping:meta::pure::mapping::Mapping[1],
                                                                          runtime:meta::pure::runtime::Runtime[1],
                                                                          query:meta::external::query::graphQL::metamodel::Document[1],
                                                                          extensions:meta::pure::router::extension::RouterExtension[*]
                                                                      ):Pair<String, meta::pure::executionPlan::ExecutionPlan>[*]
{
  // fail('Error: getMutationPlansFromGraphQL not yet implemented.');
  //meta::external::query::graphQL::transformation::queryToPure::graphQLExecutableToPure(query:Document[1], root: Class<Any>[1]) : RootGraphFetchTree<Any>[1]
 println('getMutationPlansFromGraphQL');
  
  let graphFetch = meta::external::query::graphQL::transformation::queryToPure::graphQLExecutableToPure($query, $cl);
  // let persisted = meta::legend::crud::hugo::tests::persist2($cl, $query);
  let graphFetchString = $graphFetch->meta::pure::graphFetch::routing::asString(true);
  // println('graphQLExecutableToPure ( graphFetch) as string: ');
  // println($graphFetchString);

    // println('graphQLExecutableToPure ( graphFetch) as JSON: ');
      // println($graphFetch);
  // println($graphFetch.subTrees->at(0)->cast(@meta::pure::graphFetch::PropertyGraphFetchTree)->meta::pure::graphFetch::routing::asString(true));




let mutationNameAndJSONInput = meta::external::query::graphQL::transformation::queryToPure::extractMutationNameAndInputFromGQLQuery($query);
let mutationName =  $mutationNameAndJSONInput.first;
let mutationJSONInput =  $mutationNameAndJSONInput.second;

// From RootQuery:
// find the QP with name and get the only input type ( a class ie. Firm)
let mutationInputClass = meta::external::query::graphQL::transformation::queryToPure::extractInputClassFromRootQueryClass($cl, $mutationName);

// From QGL Query:
// println('Mutation name:');
// println($mutationName);
// println('Mutation JSONObject:');
// println($mutationJSONInput->toJSON());

// println('Input class from mutation with name:');
// println($mutationInputClass);

// get persist Func from RootQuery ( So we can evaluate with expected Input ( Firm ))
let persistFunc = meta::external::query::graphQL::transformation::queryToPure::extractPersistFuncFromRootQueryClass($cl, $mutationName);


// println($mutationJSONInput->toJSON());

// Given GQL JSONObject and expected Input class from RootQuery, serialize JSONObj to Pure Obj ( Firm[1]) 
let firmObjFromJson = meta::external::query::graphQL::transformation::queryToPure::persistFromJSONObject($mutationInputClass, $mutationJSONInput);


// evaluate persistFunc with Pure Object Input (Firm[1]) TODO: Plan is for persist to become a native func
let persistedFirm = $persistFunc->meta::pure::functions::lang::evaluate(^List<Any>(values=$firmObjFromJson));

println($persistedFirm->meta::json::toJSON());
// println($persistedFirmFromJson->toJSON());
// println($persistedFirmFromJson->toJSONElement()->cast(@JSONObject));


let persistedFirmJsonObj = $persistedFirm->toJSONElement()->cast(@JSONObject);

// convert GQL query to type expected by RootQuery mutation name ( QualifiedProperty name )


// meta::legend::crud::hugo::tests::persistFromJSONObject

//  meta::external::query::graphQL::transformation::queryToPure::extractMutationNameAndInputFromGQLQuery()

// println($extractedPersistQP->toOne()->meta::pure::metamodel::serialization::json::qualifiedPropertyToJSON()->meta::json::toJSON());
// meta::pure::metamodel::serialization::json::parameterToJSON($extractedPersistQP.classifierGenericType.typeArguments.rawType->cast(@FunctionType).parameters->cast(@VariableExpression)->at(1).deactivate());

// println($extractedPersistQP.expressionSequence);
//toOne()->deactivate()
//  ->cast(@QualifiedProperty<Any>).expressionSequence->toOne()->asString();
//   println($cl->classPropertyByName('persistFirme'));
//  println('properties of cl:');
//  println($cl->meta::pure::functions::meta::classQualifiedPropertyByName('persistFirm'));


//  println($cl->meta::pure::functions::meta::classQualifiedPropertyByName('persistFirm'));
// function meta::pure::metamodel::serialization::json::qualifiedPropertyToJSON(property:QualifiedProperty<Any>[1]):JSONElement[1]
// {
// function
//    {doc.doc = 'Get the property with the given name from the given class. Note that this searches only properties defined directly on the class, not those inherited from super-classes or those which come from associations.'}
//    meta::pure::functions::meta::classPropertyByName(class:Class<Any>[1], name:String[1]):Property<Nil,Any|*>[0..1]
// {
//     $class.properties->filter(p | $p.name == $name)->first()
// }

  // let property = $obj->genericType()->properties()->get($propertyName);
// meta::external::query::graphQL::transformation::queryToPure::extractClassAndPayloadFromQuery($cl, $query);
//  println($graphFetch.subTrees->at(0)->cast(@meta::pure::graphFetch::PropertyGraphFetchTree).parameters->evaluateAndDeactivate()->cast(@InstanceValue).values->
//  meta::json::toJSON());




  // .parameters->evaluateAndDeactivate()
  // ->cast(@InstanceValue));

  // print function they use 

      // rr: RootGraphFetchTree<Any>[1] |
      //    $space + '#{'+$rr.class->elementToPath() +
      //    if($rr.subTrees->isEmpty(), | '}#', | $rr.subTrees->map(x | $x->asString($space + '    ', $multiLine))->joinStrings(' {'+$newLine, ', '+$newLine, $newLine + $space + '}}#')),


//         rp: PropertyGraphFetchTree[1] |
//          $space +  $rp.property.name->toOne() + if($rp.property->instanceOf(QualifiedProperty), |'('+$rp.parameters->evaluateAndDeactivate()->map(p|$p->asString())->joinStrings(', ')+')', |'') +
//          if($rp.subTrees->isEmpty(), | '', | $rp.subTrees->map(x | $x->asString($space + '    ', $multiLine))->joinStrings(' {'+$newLine, ', '+$newLine, $newLine + $space + '}'));
//  ]); 
  // let res = $graphFetch->meta::pure::graphFetch::domain::extractDomainTypeClassFromGraphWriteTree();
  // println('extractDomainTypeClassFromGraphWriteTree result: ');
  // println($res->at(0).first);
  // println($res->at(0).second->meta::pure::router::printer::asString());
  // println('done');
  
  // let domainTypeClassString = $domainTypeClass->meta::pure::graphFetch::routing::asString(true);


  let graphWriteNode = ^meta::pure::graphFetch::executionPlan::GraphWriteNode(
    class=$cl, 
    action=meta::pure::graphFetch::executionPlan::GraphWriteAction.PERSIST,
    payload=$persistedFirmJsonObj,
    selectionSet=''
  );


  let graphWriteExecutionNode = ^GraphWriteExecutionNode(node=[$graphWriteNode], resultType=^ResultType(type = Boolean));

  let executionPlan =  ^ExecutionPlan
   (
      func =  meta::pure::graphFetch::execution::serialize_T_MANY__RootGraphFetchTree_1__String_1_,
      mapping = $mapping,
      runtime = $runtime,
      rootExecutionNode = $graphWriteExecutionNode,
      authDependent = false,
      kerberos =  'test'
   );
   
  [^Pair<String, meta::pure::executionPlan::ExecutionPlan>(first=$mutationName, second=$executionPlan)];
}

function meta::external::query::graphQL::transformation::queryToPure::getSubscriptionPlansFromGraphQL(
                                                                          cl:Class<Any>[1],
                                                                          mapping:meta::pure::mapping::Mapping[1],
                                                                          runtime:meta::pure::runtime::Runtime[1],
                                                                          query:meta::external::query::graphQL::metamodel::Document[1],
                                                                          extensions:meta::pure::router::extension::RouterExtension[*]
                                                                      ):Pair<String, meta::pure::executionPlan::ExecutionPlan>[*]
{
  println('Error: getSubscriptionPlansFromGraphQL not yet implemented.');
  [];
}

function meta::external::query::graphQL::transformation::queryToPure::getQueryPlansFromGraphQL(
                                                                          cl:Class<Any>[1],
                                                                          mapping:meta::pure::mapping::Mapping[1],
                                                                          runtime:meta::pure::runtime::Runtime[1],
                                                                          query:meta::external::query::graphQL::metamodel::Document[1],
                                                                          extensions:meta::pure::router::extension::RouterExtension[*]
                                                                      ):Pair<String, meta::pure::executionPlan::ExecutionPlan>[*]
{
  let graphFetch = meta::external::query::graphQL::transformation::queryToPure::graphQLExecutableToPure($query, $cl);
  let graphFetchString = $graphFetch->meta::pure::graphFetch::routing::asString(true);
  // assertEquals('', $graphFetchString);
  println('graphQLExecutableToPure ( graphFetch) as string: ');
  println($graphFetchString);
  let res = $graphFetch->meta::pure::graphFetch::domain::extractDomainTypeClassFromGraphFetchTree();
  println('extractDomainTypeClassFromGraphFetchTree result: ');
  println($res->at(0).first);
  println($res->at(0).second->meta::pure::router::printer::asString());
  println('done');
  $res->map(r|
              pair(
                $r.first,
                meta::pure::executionPlan::executionPlan(
                  $r.second,
                  $mapping,
                  $runtime,
                  $extensions
                )
              )
        );
}

function meta::external::query::graphQL::transformation::queryToPure::getPlansFromGraphQL(
                                                                          cl:Class<Any>[1],
                                                                          mapping:meta::pure::mapping::Mapping[1],
                                                                          runtime:meta::pure::runtime::Runtime[1],
                                                                          query:meta::external::query::graphQL::metamodel::Document[1],
                                                                          extensions:meta::pure::router::extension::RouterExtension[*]
                                                                      ):Pair<String, meta::pure::executionPlan::ExecutionPlan>[*]
{
  // TODO: how to handle multiple queries ( should we assume OperationDefinition type will be same for all? )
  let operationType = $query.definitions->at(0)->cast(@meta::external::query::graphQL::metamodel::executable::OperationDefinition).type;

  // How to do this with match?
  if ($operationType.name == 'query',
      |  meta::external::query::graphQL::transformation::queryToPure::getQueryPlansFromGraphQL($cl, $mapping, $runtime, $query, $extensions);,
      | if ($operationType.name == 'mutation',
      | meta::external::query::graphQL::transformation::queryToPure::getMutationPlansFromGraphQL($cl, $mapping, $runtime, $query, $extensions);,
      | if ($operationType.name == 'subscription',
      | meta::external::query::graphQL::transformation::queryToPure::getSubscriptionPlansFromGraphQL($cl, $mapping, $runtime, $query, $extensions);,
      | println('Unrecognized operation type!'))));

}

Class meta::external::query::graphQL::transformation::queryToPure::GraphFetchResult
{
  graphFetchTree : meta::pure::graphFetch::RootGraphFetchTree<Any>[1];
  explodedDomain : Pair<String, FunctionDefinition<{->Any[*]}>>[*];
}

function meta::external::query::graphQL::transformation::queryToPure::getGraphFetchFromGraphQL(cl:Class<Any>[1], query:meta::external::query::graphQL::metamodel::Document[1]):GraphFetchResult[1]
{
  let graphFetch = meta::external::query::graphQL::transformation::queryToPure::graphQLExecutableToPure($query, $cl);
  let res = $graphFetch->meta::pure::graphFetch::domain::extractDomainTypeClassFromGraphFetchTree();
  ^GraphFetchResult
  (
    graphFetchTree = $graphFetch,
    explodedDomain = $res->map(r|pair($r.first, $r.second))
  );
}

